# QoS/Rate Limiting Demo
# Demonstrates: Per-subscriber bandwidth control via eBPF TC token bucket
#
# Architecture:
# +-------------------------------------------------------------+
# |                    demo-qos namespace                        |
# |  +----------------------------------------------------------+
# |  |                   Pod: qos-test                          |
# |  |  +------------+         +-------------+  +-----------+   |
# |  |  |   BNG      |  veth   |   Client    |  |  Server   |   |
# |  |  | (QoS TC)   |<------->| (iperf3     |  | (iperf3   |   |
# |  |  | eBPF rate  |         |  client)    |  |  server)  |   |
# |  |  | limiting   |         |             |  |           |   |
# |  |  +------------+         +-------------+  +-----------+   |
# |  +----------------------------------------------------------+
# +-------------------------------------------------------------+
#
# QoS Features Demonstrated:
# 1. Per-subscriber download rate limiting (e.g., 10 Mbps)
# 2. Per-subscriber upload rate limiting (e.g., 5 Mbps)
# 3. Burst handling (token bucket allows short bursts)
# 4. Multiple subscribers with different rate limits
# 5. Statistics collection (packets/bytes passed/dropped)
#
# Token Bucket Algorithm:
# - Tokens accumulate at configured rate (bits per second)
# - Each packet consumes tokens equal to its size
# - If insufficient tokens, packet is dropped
# - Burst size determines maximum tokens (allows short bursts)

apiVersion: v1
kind: Namespace
metadata:
  name: demo-qos
---
# ConfigMap with QoS test scripts
apiVersion: v1
kind: ConfigMap
metadata:
  name: qos-scripts
  namespace: demo-qos
data:
  # Script to configure rate limits for a subscriber
  configure-rate-limit.sh: |
    #!/bin/sh
    # Configure rate limit for a subscriber
    # Usage: configure-rate-limit.sh <IP> <DOWNLOAD_MBPS> <UPLOAD_MBPS> [BURST_KB]
    set -e

    IP="${1:-10.100.0.100}"
    DOWNLOAD_MBPS="${2:-10}"
    UPLOAD_MBPS="${3:-5}"
    BURST_KB="${4:-128}"  # Default 128KB burst

    # Convert to bits per second
    DOWNLOAD_BPS=$((DOWNLOAD_MBPS * 1000000))
    UPLOAD_BPS=$((UPLOAD_MBPS * 1000000))
    BURST_BYTES=$((BURST_KB * 1024))

    echo "=== Configuring QoS Rate Limit ==="
    echo "Subscriber IP:  $IP"
    echo "Download Rate:  $DOWNLOAD_MBPS Mbps ($DOWNLOAD_BPS bps)"
    echo "Upload Rate:    $UPLOAD_MBPS Mbps ($UPLOAD_BPS bps)"
    echo "Burst Size:     $BURST_KB KB ($BURST_BYTES bytes)"
    echo ""

    # Use BNG CLI to set rate limit (or direct bpftool if available)
    if command -v bng >/dev/null 2>&1; then
      bng qos set --ip="$IP" --download-bps="$DOWNLOAD_BPS" --upload-bps="$UPLOAD_BPS" --burst-bytes="$BURST_BYTES"
    else
      echo "BNG CLI not found, using bpftool directly..."
      # The eBPF map key is IP in network byte order (big endian uint32)
      # For 10.100.0.100 = 0x0A640064
      # Token bucket struct: tokens(u64), last_update(u64), rate_bps(u64), burst_bytes(u32), priority(u8), pad[3]
      echo "Note: Direct bpftool configuration would be done here"
    fi

    echo ""
    echo "Rate limit configured successfully!"

  # Script to generate traffic and measure throughput
  measure-throughput.sh: |
    #!/bin/sh
    # Generate traffic and measure actual throughput
    # Usage: measure-throughput.sh [DURATION_SEC] [PARALLEL_STREAMS]
    set -e

    DURATION="${1:-10}"
    PARALLEL="${2:-1}"
    SERVER_IP="${SERVER_IP:-10.100.0.1}"

    echo "=== Traffic Generation and Measurement ==="
    echo "Server IP:      $SERVER_IP"
    echo "Duration:       ${DURATION}s"
    echo "Parallel:       $PARALLEL streams"
    echo ""

    echo "--- Download Test (Server -> Client) ---"
    echo "Running iperf3 download test..."
    iperf3 -c "$SERVER_IP" -t "$DURATION" -P "$PARALLEL" -R 2>/dev/null || echo "Download test failed"

    echo ""
    echo "--- Upload Test (Client -> Server) ---"
    echo "Running iperf3 upload test..."
    iperf3 -c "$SERVER_IP" -t "$DURATION" -P "$PARALLEL" 2>/dev/null || echo "Upload test failed"

    echo ""
    echo "=== Measurement Complete ==="

  # Script to verify rate limiting is enforced
  verify-rate-limiting.sh: |
    #!/bin/sh
    # Verify that rate limiting is enforced by comparing actual vs expected throughput
    # Usage: verify-rate-limiting.sh <EXPECTED_DOWNLOAD_MBPS> <EXPECTED_UPLOAD_MBPS>
    set -e

    EXPECTED_DOWNLOAD="${1:-10}"
    EXPECTED_UPLOAD="${2:-5}"
    SERVER_IP="${SERVER_IP:-10.100.0.1}"
    TOLERANCE=20  # Allow 20% variance

    echo "=== Rate Limiting Verification ==="
    echo "Expected Download: ${EXPECTED_DOWNLOAD} Mbps"
    echo "Expected Upload:   ${EXPECTED_UPLOAD} Mbps"
    echo "Tolerance:         +/- ${TOLERANCE}%"
    echo ""

    # Run download test and capture result
    echo "Running download test..."
    DOWNLOAD_RESULT=$(iperf3 -c "$SERVER_IP" -t 5 -R -J 2>/dev/null | grep -o '"bits_per_second":[0-9.]*' | tail -1 | cut -d: -f2)
    if [ -n "$DOWNLOAD_RESULT" ]; then
      DOWNLOAD_MBPS=$(echo "$DOWNLOAD_RESULT" | awk '{printf "%.2f", $1/1000000}')
      echo "Actual Download: $DOWNLOAD_MBPS Mbps"

      # Check if within tolerance
      MIN_DOWNLOAD=$(echo "$EXPECTED_DOWNLOAD" | awk -v t="$TOLERANCE" '{printf "%.2f", $1 * (100-t) / 100}')
      MAX_DOWNLOAD=$(echo "$EXPECTED_DOWNLOAD" | awk -v t="$TOLERANCE" '{printf "%.2f", $1 * (100+t) / 100}')

      if awk "BEGIN {exit !($DOWNLOAD_MBPS >= $MIN_DOWNLOAD && $DOWNLOAD_MBPS <= $MAX_DOWNLOAD)}"; then
        echo "PASS: Download rate within expected range ($MIN_DOWNLOAD - $MAX_DOWNLOAD Mbps)"
      else
        echo "FAIL: Download rate outside expected range"
      fi
    else
      echo "Could not measure download rate"
    fi

    echo ""

    # Run upload test and capture result
    echo "Running upload test..."
    UPLOAD_RESULT=$(iperf3 -c "$SERVER_IP" -t 5 -J 2>/dev/null | grep -o '"bits_per_second":[0-9.]*' | tail -1 | cut -d: -f2)
    if [ -n "$UPLOAD_RESULT" ]; then
      UPLOAD_MBPS=$(echo "$UPLOAD_RESULT" | awk '{printf "%.2f", $1/1000000}')
      echo "Actual Upload: $UPLOAD_MBPS Mbps"

      # Check if within tolerance
      MIN_UPLOAD=$(echo "$EXPECTED_UPLOAD" | awk -v t="$TOLERANCE" '{printf "%.2f", $1 * (100-t) / 100}')
      MAX_UPLOAD=$(echo "$EXPECTED_UPLOAD" | awk -v t="$TOLERANCE" '{printf "%.2f", $1 * (100+t) / 100}')

      if awk "BEGIN {exit !($UPLOAD_MBPS >= $MIN_UPLOAD && $UPLOAD_MBPS <= $MAX_UPLOAD)}"; then
        echo "PASS: Upload rate within expected range ($MIN_UPLOAD - $MAX_UPLOAD Mbps)"
      else
        echo "FAIL: Upload rate outside expected range"
      fi
    else
      echo "Could not measure upload rate"
    fi

  # Script to test burst handling
  burst-test.sh: |
    #!/bin/sh
    # Test burst handling - verify short bursts are allowed
    # Usage: burst-test.sh [BURST_SIZE_KB]
    set -e

    BURST_SIZE_KB="${1:-128}"
    SERVER_IP="${SERVER_IP:-10.100.0.1}"

    echo "=== Burst Handling Test ==="
    echo "Expected Burst Size: ${BURST_SIZE_KB} KB"
    echo ""

    # Test 1: Small burst (should pass completely)
    SMALL_BURST=$((BURST_SIZE_KB / 2))
    echo "Test 1: Small burst (${SMALL_BURST} KB) - should pass completely"
    dd if=/dev/zero bs=1K count="$SMALL_BURST" 2>/dev/null | nc -w1 "$SERVER_IP" 5201 2>/dev/null && echo "  Result: PASS" || echo "  Result: Could not connect"

    echo ""

    # Test 2: Large burst (should be partially dropped/delayed)
    LARGE_BURST=$((BURST_SIZE_KB * 4))
    echo "Test 2: Large burst (${LARGE_BURST} KB) - expect rate limiting"
    echo "Sending large burst and measuring time..."
    START=$(date +%s.%N)
    dd if=/dev/zero bs=1K count="$LARGE_BURST" 2>/dev/null | nc -w5 "$SERVER_IP" 5201 2>/dev/null
    END=$(date +%s.%N)
    ELAPSED=$(echo "$END - $START" | bc 2>/dev/null || echo "N/A")
    echo "  Elapsed time: ${ELAPSED}s"
    echo "  (Longer time indicates rate limiting is working)"

    echo ""
    echo "=== Burst Test Complete ==="

  # Script to test per-subscriber rate limits
  multi-subscriber-test.sh: |
    #!/bin/sh
    # Test that different subscribers can have different rate limits
    set -e

    echo "=== Per-Subscriber Rate Limit Test ==="
    echo ""
    echo "This test demonstrates that different subscribers can have different rate limits."
    echo ""

    # Subscriber 1: Basic plan (10 Mbps down / 5 Mbps up)
    echo "Subscriber 1: Basic Plan"
    echo "  IP: 10.100.0.100"
    echo "  Download: 10 Mbps"
    echo "  Upload: 5 Mbps"
    /scripts/configure-rate-limit.sh 10.100.0.100 10 5 128

    echo ""

    # Subscriber 2: Premium plan (50 Mbps down / 20 Mbps up)
    echo "Subscriber 2: Premium Plan"
    echo "  IP: 10.100.0.101"
    echo "  Download: 50 Mbps"
    echo "  Upload: 20 Mbps"
    /scripts/configure-rate-limit.sh 10.100.0.101 50 20 256

    echo ""

    # Subscriber 3: Business plan (100 Mbps down / 100 Mbps up)
    echo "Subscriber 3: Business Plan"
    echo "  IP: 10.100.0.102"
    echo "  Download: 100 Mbps"
    echo "  Upload: 100 Mbps"
    /scripts/configure-rate-limit.sh 10.100.0.102 100 100 512

    echo ""
    echo "=== All Subscriber Policies Configured ==="

  # Script to display QoS statistics
  show-stats.sh: |
    #!/bin/sh
    # Display QoS statistics from eBPF maps
    set -e

    echo "=== QoS Statistics ==="
    echo ""

    if command -v bng >/dev/null 2>&1; then
      echo "Using BNG CLI..."
      bng qos stats
    elif command -v bpftool >/dev/null 2>&1; then
      echo "Using bpftool..."
      echo ""
      echo "--- QoS Stats Map ---"
      bpftool map dump name qos_stats_map 2>/dev/null || echo "Map not found"
      echo ""
      echo "--- Egress (Download) Policies ---"
      bpftool map dump name qos_egress 2>/dev/null | head -50 || echo "Map not found"
      echo ""
      echo "--- Ingress (Upload) Policies ---"
      bpftool map dump name qos_ingress 2>/dev/null | head -50 || echo "Map not found"
    else
      echo "Neither BNG CLI nor bpftool available"
      echo "Stats would show:"
      echo "  - Packets passed"
      echo "  - Packets dropped"
      echo "  - Bytes passed"
      echo "  - Bytes dropped"
    fi

    echo ""
    echo "=== End Statistics ==="

  # Main demo script
  run-demo.sh: |
    #!/bin/sh
    # Complete QoS rate limiting demonstration
    set -e

    echo "========================================"
    echo "   BNG QoS/Rate Limiting Demonstration"
    echo "========================================"
    echo ""
    echo "This demo shows eBPF-based per-subscriber bandwidth control:"
    echo "  - Token bucket algorithm for smooth rate limiting"
    echo "  - Separate download (egress) and upload (ingress) limits"
    echo "  - Configurable burst sizes"
    echo "  - Per-subscriber policies"
    echo ""
    echo "Press Enter to start..."
    read _

    # Step 1: Configure rate limit
    echo ""
    echo "========================================"
    echo "Step 1: Configure Rate Limit"
    echo "========================================"
    echo "Setting up 10 Mbps download / 5 Mbps upload with 128KB burst"
    /scripts/configure-rate-limit.sh 10.100.0.100 10 5 128

    echo ""
    echo "Press Enter to continue..."
    read _

    # Step 2: Measure baseline (before rate limiting)
    echo ""
    echo "========================================"
    echo "Step 2: Measure Throughput"
    echo "========================================"
    /scripts/measure-throughput.sh 5

    echo ""
    echo "Press Enter to continue..."
    read _

    # Step 3: Verify rate limiting
    echo ""
    echo "========================================"
    echo "Step 3: Verify Rate Limiting"
    echo "========================================"
    /scripts/verify-rate-limiting.sh 10 5

    echo ""
    echo "Press Enter to continue..."
    read _

    # Step 4: Burst test
    echo ""
    echo "========================================"
    echo "Step 4: Burst Handling Test"
    echo "========================================"
    /scripts/burst-test.sh 128

    echo ""
    echo "Press Enter to continue..."
    read _

    # Step 5: Show stats
    echo ""
    echo "========================================"
    echo "Step 5: QoS Statistics"
    echo "========================================"
    /scripts/show-stats.sh

    echo ""
    echo "========================================"
    echo "   Demo Complete!"
    echo "========================================"
    echo ""
    echo "Key takeaways:"
    echo "  - eBPF TC programs enforce rate limits at kernel level"
    echo "  - Token bucket allows controlled bursting"
    echo "  - Different subscribers can have different policies"
    echo "  - Statistics track passed vs dropped packets/bytes"
---
# BNG + Client + Server pod for QoS testing
apiVersion: v1
kind: Pod
metadata:
  name: qos-test
  namespace: demo-qos
  labels:
    app: qos-test
  annotations:
    prometheus.io/scrape: "true"
    prometheus.io/port: "9090"
    prometheus.io/path: "/metrics"
spec:
  shareProcessNamespace: true

  initContainers:
    # Setup L2 network with veth pairs
    - name: network-setup
      image: nicolaka/netshoot:latest
      command: ["/bin/sh", "-c"]
      args:
        - |
          echo "=== Setting up QoS test network ==="

          # Create veth pair: bng <-> client
          ip link add veth-bng type veth peer name veth-client
          ip addr add 10.100.0.1/24 dev veth-bng
          ip addr add 10.100.0.100/24 dev veth-client
          ip link set veth-bng up
          ip link set veth-client up

          # Enable IP forwarding
          echo 1 > /proc/sys/net/ipv4/ip_forward

          echo "Network configuration:"
          echo "  veth-bng:    10.100.0.1/24 (BNG interface - QoS enforced here)"
          echo "  veth-client: 10.100.0.100/24 (Subscriber interface)"
          echo ""
          echo "Network ready for QoS testing!"
      securityContext:
        privileged: true
        capabilities:
          add: ["NET_ADMIN", "NET_RAW", "SYS_ADMIN"]

  containers:
    # BNG with QoS enabled
    - name: bng
      image: ghcr.io/codelaboratoryltd/bng:latest
      args:
        - "run"
        - "--interface=veth-bng"
        - "--qos-enabled=true"
        
      securityContext:
        privileged: true
        capabilities:
          add: ["NET_ADMIN", "NET_RAW", "SYS_ADMIN", "BPF"]
      volumeMounts:
        - name: bpffs
          mountPath: /sys/fs/bpf
        - name: scripts
          mountPath: /scripts
          readOnly: true
      env:
        - name: QOS_ENABLED
          value: "true"
        - name: QOS_INTERFACE
          value: "veth-bng"

    # iperf3 server for traffic generation
    - name: server
      image: networkstatic/iperf3:latest
      args: ["-s", "-p", "5201"]
      ports:
        - containerPort: 5201
          name: iperf3

    # Client container for running tests
    - name: client
      image: nicolaka/netshoot:latest
      command: ["sleep", "infinity"]
      securityContext:
        privileged: true
        capabilities:
          add: ["NET_ADMIN", "NET_RAW"]
      volumeMounts:
        - name: scripts
          mountPath: /scripts
          readOnly: true
      env:
        - name: SERVER_IP
          value: "10.100.0.1"

  volumes:
    - name: bpffs
      hostPath:
        path: /sys/fs/bpf
        type: DirectoryOrCreate
    - name: scripts
      configMap:
        name: qos-scripts
        defaultMode: 0755
---
# Service for accessing the test pod
apiVersion: v1
kind: Service
metadata:
  name: qos-test
  namespace: demo-qos
spec:
  selector:
    app: qos-test
  ports:
    - port: 9090
      targetPort: 9090
      name: metrics
    - port: 5201
      targetPort: 5201
      name: iperf3
